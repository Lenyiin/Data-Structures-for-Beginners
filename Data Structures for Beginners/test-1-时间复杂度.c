#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>

//B站	P1-P13


//数据结构（初阶）入门 + 中等的数据结构讲解			C语言（指针、结构、库函数、内存管理）		20节课			60课时
//C++		50节课		C++语言+STL+高阶数据结构

//Linux		Linux环境+系统编程+网络编程+数据库

//项目

//笔试强训

//算法课




//Lesson1：数据结构前言
//1.什么是数据结构
//2.什么是算法
//3.数据结构和算法的重要性
//4.如何学好数据结构和算法
//5.数据结构和算法书籍及资料推荐


//1.什么是数据结构
//	数据结构（Data Structure）是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素集合
//2.什么是算法
//	算法（Algorithm）：就是定义良好的计算过程，他取一个或一组的指为输入，并产生出一个或一组值作为输出。
//	简单来说，算法就是一系列的计算步骤，用来将输入数据转化成输出结果。




//Lesson2：算法的时间复杂度和空间复杂度
//1.算法效率
//2.时间复杂度
//3.空间复杂度
//4.常见时间复杂度以及复杂度oj练习


//1.算法效率
//	衡量一个算法的好坏，一般是从时间和空间两个维度来衡量的，即时间复杂度和空间复杂度。
//	时间复杂度主要衡量一个算法的运行快慢，而空间复杂度主要衡量一个算法运行所需要的额外空间。
//2.时间复杂度
//	算法的时间复杂度是一个函数。算法中的基本操作的执行次数，为算法的时间复杂度。
//2.2 大O的渐进表示法		大O符号：是用于描述函数渐进行为的数学符号
//		1.用常数1取代运行时间中的所有加法常数
//		2.再修改后的运行次数函数中，只保留最高阶
//		3.如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶
//	O(1)	不是代表算法运行一次，是常数次
//	当一个算法随着输入不同，时间复杂度不同，时间复杂度做悲观预期，看最坏的情况。


//二分查找算法是一个非常牛逼的算法
//N个数查找				大概查找次数
//1000					10
//100w					20
//10亿					30

//树 --> 二叉树 --> 搜索二叉树 --> 平衡搜索二叉树 --> AVLTree RBTree --> 哈希表 -->B数

//递归算法：递归次数*每次递归调用的次数


//斐波那契数列的递归写法完全是一个实际中没用的算法，因为太慢了
//O(2^N)
//long long Fib(size_t N)
//{
//	if (N < 3)
//	{
//		return 1;
//	}
//	return Fib(N - 1) + Fib(N - 2);
//}
//int main()
//{
//	printf("%lld\n", Fib(100));
//	return 0;
//}




//3.空间复杂度
//	空间复杂度也是一个数学函数表达式，是对一个算法在运行过程中临时占用内存空间大小的度量。
//	空间复杂度不是程序占用了多少bytes的空间，因为没有太大意义，空间复杂度算的是变量的个数，规则跟时间复杂度类似，也使用大O渐进表示法
//	注意：函数运行时所需要的栈空间（储存参数、局部变量、一些寄存器信息等）在编译期间已经确定好了，因此空间复杂度主要通过函数在运行时候显示申请的额外空间来确定

//空间是可以重复利用，不累计
//时间是一去不复返，累积的


//作业	消失的数字
//数组nums包含从0-n的所有数字，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O（n）时间内完成吗?
//思路1：排序 --> qsort快排 --> 时间复杂度O（n*log2N）			不符合要求
//思路2：（0+1+2+...+n）-（a[0]+a[1]+...+a[n-1])
//思路3：数组中的值是几，就在几的位置写一个这个值
//思路4：给一个值x=0，x先跟[0,n]的所有值异或，x再跟数组中的每个值异或，最后x就是却的那个数。

//一道题有多种方法，我们不用实现，只需要分析出每种方法的复杂度选择复杂度优的方式即可，这就是复杂度在实际中意义。
//int missingNumber(int* nums, int numSize)
//{
//	int x = 0;
//	int i = 0;
//	//跟[0,n]异或
//	for ( i = 0; i <= numSize; i++)
//	{
//		x ^= i;
//	}
//	//再跟数组中值异或
//	for (i = 0; i < numSize; i++)
//	{
//		x ^= nums[i];
//	}
//	return x;
//}
//int main()
//{
//	int arr[] = { 0,1,2,3,4,5,6,7,8,9,10,12 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int ret = missingNumber(arr, sz);
//	printf("%d\n", ret);
//	return 0;
//}



//作业		旋转数组
//给定一个数组，将数组中的元素向右移动k个位置，其中k是非负数
//尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题
//你可以使用空间复杂度为O(1)的原地算法解决这个问题吗？

//思路1：暴力求解，旋转K次
//		时间复杂度O（N*K）		空间复杂度O(1)
//void rotate(int* nums, int numsSize, int k) {				//时间复杂度太高
//	while (k--)
//	{
//		int tmp = nums[numsSize - 1];
//		for (int end = numsSize - 2; end >= 0; --end)
//		{
//			nums[end + 1] = nums[end];
//		}
//		nums[0] = tmp;
//	}
//}
//思路2：开辟额外的空间		时间复杂度O（N）		空间复杂度O(N)

//思路3：前n-k个逆置，后k个逆置，整体逆置		时间复杂度O（N）		空间复杂度O(1)
//void Reverse(int* nums, int left, int right)
//{
//	while (left < right)
//	{
//		int tmp = nums[left];
//		nums[left] = nums[right];
//		nums[right] = tmp;
//		left++;
//		right--;
//	}
//}
//void rotate(int* nums, int numsSize, int k)
//{
//	if (k >= numsSize)
//	{
//		k %= numsSize;
//	}
//	//前n-k个数逆置
//	Reverse(nums, 0, numsSize - k - 1);
//	//后k个数的逆置
//	Reverse(nums, numsSize - k, numsSize - 1);
//	//再整体逆置
//	Reverse(nums, 0, numsSize - 1);
//}
//int main()
//{
//	int arr[] = { 0,1,2,3,4,5,6,7,8,9,10 };
//	int k = 3;
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	rotate(arr, sz, k);
//	for (int i = 0; i < sz; i++)
//	{
//		printf("%d ", arr[i]);
//	}
//	return 0;
//}